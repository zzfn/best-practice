> 在注释处补充段代码以达到运行后结果
```js
let a = 0;
let lazy = {
  add() {
    a++;
    // return this
  }
}
lazy.add().add()
```
> 原型链输出结果题
```js
function fun() {};
var f = new fun();

f.__proto__ // === ? 1 fun.prototype
f.__proto__.__proto__ // === ? 2 Object.prototype
f.__proto__.__proto__.__proto__ // === ? 3 null
f.__proto__.__proto__.__proto__.__proto__ // === ? 4  抛错
fun.__proto__ // === ? 5 Function.prototype
fun.__proto__.__proto__ // === ? 6 Object.prototype
f.prototype // ? 7 undefined
```
特别注意⚠️ 只有fun.__proto__才会指向Funtion.prototype 对象的__proto__链条上不会有Funtion出现
> 改写题
```js
class Demo {
    a = 1;
    m1() {}
    m2 = () => {}
    static s2 = 2;
}

// 改写为ES5的方式
function Demo(){
    this.a = 1
    this.m2 = ()=>{}
}
Demo.s2 = 2
Demo.prototype.m1 = function(){} 
```
> Promsie.all 并行改串行

> 手写实现promsie.all   如果后面还想继续链式调用呢？

> 树组件
```js
export const treeData = [
  {
    key: '1',
    name: '1',
    children: [
      {
        key: '1.1',
        name: '1.1',
        children: [
          {
              key: '1.1.1',
              name: '1.1.1'
          }
        ]
      },
    ]
  },
  {
    key: '2',
    name: '2',
    children: [
      {
        key: '2.1',
        name: '2.1',
      },
    ]
  }
]


// 核心实现 递归

renderMenu = (data) => {
  return data.map((item)=>{
    if(item.children){
      return <SubMenu  key={item.key} title={item.title}>
      { this.renderMenu(item.children) }
      </SubMenu>
    }
    return <Menu.Item key={item.key} title={item.title}>{item.title}</Menu.Item>
  })
}
```
> 事件循环
```js
setTimeout(function() {  
console.log(1)}, 0
);


new Promise(function executor(resolve) {  
console.log(2); 
for( var i=0 ; i<10000 ; i++ ) {    
i == 9999 && resolve(); 
}  
console.log(3);
}
).then(function() {  
console.log(4);
});

console.log(5);
```
> 实现
```js
 for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(new Date(), i);}, 
  1000);
 }
    console.log(new Date(), i)
// 一直在围绕着做各种变形
// 第一次输出和最后一次输出时间差
// 如何让第六行后输出
```
